#!/bin/bash

# Program 1: Stats

# Usage
# stats { -rows | -cols } [input_file]

# Citations:
# The Linux Command Line (TCLC)
# Redirect to standard out using >&2 at end of echo: TLCL Page 388 
# note: $# is the number of arguments

# GLOBALS
interactive_mode=false
cols_mode=false

# CONSTANTS
USAGE_STRING='{-rows | -cols} [input_file]'
SCRIPT_NAME=$(basename $0)  # Cite TLCL Page 440

# Return 0 if number of arguments is 0 or 1, else print usage message and exit
validate_num_args () {
	# echo "Arguments inside validate: $1"
	if [[ "$1" == 1 ]]; then
		set_interactive_mode true
	elif [[ "$1" == 2 ]]; then
		return 0  # success
	else
		print_usage
	fi
		return 0
}


# Return 0 (true) if argument 1 is valid format -r* or -c* regex
# If it does not match, exits with usage message
# Citation: Use of =~ to test against a regex- TLCL Page 389
validate_arg1 () {
	# echo "called validate_arg1 with: $1"
	if [[ "$1" =~ ^-r.*$ ]]; then
		# echo "Matched regex with -r"
		set_cols_mode false
		return 0  # true
	elif [[ "$1" =~ ^-c.*$ ]]; then
		# echo "Matched regex with -c"
		set_cols_mode true
		return 0  # true
	else
		echo "Invalid syntax" >&2 # TODO: Print more appropriate error message
		print_usage
	fi
}


set_interactive_mode () {
	# echo 'called set_interactive_mode()'
	interactive_mode=$1
	return
}

# Sets cols_mode global to be either true or false (by argument passed)
set_cols_mode () {
	cols_mode=$1;
	return
}

read_from_file () {
	echo 'Hello from read_from_file()'
	if [[ ! -e "$1" ]]; then
		echo "File '$1' does not exist" >&2
		exit 1
	elif [[ ! -r "$1" ]]; then
		echo "File '$1' not readable" >&2
		exit 1
	elif [[ -f "$1" ]]; then
		# File exists, try to open it and process the data
		echo 'File exists, attempting to open and parse.'
	fi
	return
}

convert_to_cols () {
	input_file=$1
	tempRow="temprowfile"
	# TODO: FINISH
}

read_from_stdin () {
	echo "Hello from read_from_stdin"
	return
}

# process_data () {
# 	echo "Hello from process_data"
# 	return
# }

# Displays usage to user
print_usage () {
	echo "$SCRIPT_NAME: Usage: $SCRIPT_NAME $USAGE_STRING" >&2 
	exit 1
}


# main

# Put the arguments into more meaningful variable names
num_args=$#
process_mode=$1
file_name=$2

# Validate the command line arguments and attempt to open file
# echo "Number of arguments: $#"
validate_num_args $num_args
validate_arg1 $process_mode
echo "interactive mode: $interactive_mode" # TODO: COMMENT OUT AND/OR DELETE
echo "Calculating on columns: $cols_mode" # TODO: COMMENT OUT AND/OR DELETE


# Create a file if in creative mode
if [[ $interactive_mode == true ]] ; then
	# read_from_stdin
	echo "Here we would read from standard input and store in a file" # TODO: COMMENT OUT AND/OR DELETE
	file_name=./temp  # change to whatever file we end up storing our temp data
fi

# Convert a row file to a column file if cosl_mode is set
if [[ $cols_mode == true ]]; then
	convert_to_cols $file_name
fi

# read each row from $file_name and process
# Citation: TLCL Page 414

# Arrays to store the averages and medians in
declare -a averages
declare -a medians
current_row=0

while read row_string; do  # row_string is the string form
	i=0
	row_sum=0
	row_no_tabs="$(echo $row_string | tr '\t' ' ')"
	declare -a row_values # array to store the actual values
	for j in $row_no_tabs; do
		row_values[i]=$j
		# echo ${row_values[i]\n}
		row_sum=$(($row_sum + $j))
		let i++
	done
	# echo "row_sum: $row_sum"

	# Sort the array for this row
	# Citation: Page 484 of TLCL
	row_sorted=($(for k in "${row_values[@]}"; do echo $k; done | sort -n))
	echo "Sorted array: ${row_sorted[@]}" # TODO: COMMENT OUT AND/OR DELETE
	
	# Calculate the number of values in the row
	num_values=${#row_sorted[@]}  # size of the array. Cite: Pg 483 TLCL
	# echo "num_values: $num_values"
	
	# Calculate the average for this row
	row_average=$(( $row_sum / $num_values ))
	row_remainder=$(( $row_sum % $num_values ))

	# If we have a decimal value greater than or equal to .5, round up to next integer	
	if [[ $(( $row_remainder * 2 )) -ge $num_values ]] ; then
		let row_average++
	fi
	averages[current_row]=$row_average
	# echo "row_average: $row_average"
	# echo "Average calculated and stored: ${averages[current_row]}" # TODO: COMMENT OUT AND/OR DELETE

	# Median is middle value. $num_values / 2 gets us correct index if odd 
	# (e.g. 9/2 = 4.5 = 4 in integer math, which is 5th value in array)
	# If $num_values is even, it's the same because the greater of 2 middle values is the one with the higher index
	# (e.g. 12/2 = 6, which is 7th array element and is greater than 6th)
	middle=$(( $num_values / 2 ))
	# echo "middle: $middle"
	row_median=${row_sorted[middle]}
	medians[current_row]=$row_median
	# echo "Median calculated and stored: ${medians[current_row]}" # TODO: COMMENT OUT AND/OR DELETE

	# echo "Next row..." # TODO: COMMENT OUT AND/OR DELETE
	let current_row++
done < $file_name

# echo "$row\n"
# echo "$row_sum"
# process_data